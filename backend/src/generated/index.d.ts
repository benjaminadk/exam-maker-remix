// Code generated by Prisma (prisma@1.27.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  choice: (where?: ChoiceWhereInput) => Promise<boolean>;
  coverNode: (where?: CoverNodeWhereInput) => Promise<boolean>;
  exam: (where?: ExamWhereInput) => Promise<boolean>;
  explanationNode: (where?: ExplanationNodeWhereInput) => Promise<boolean>;
  question: (where?: QuestionWhereInput) => Promise<boolean>;
  questionNode: (where?: QuestionNodeWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  choice: (where: ChoiceWhereUniqueInput) => ChoicePromise;
  choices: (
    args?: {
      where?: ChoiceWhereInput;
      orderBy?: ChoiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Choice>;
  choicesConnection: (
    args?: {
      where?: ChoiceWhereInput;
      orderBy?: ChoiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ChoiceConnectionPromise;
  coverNode: (where: CoverNodeWhereUniqueInput) => CoverNodePromise;
  coverNodes: (
    args?: {
      where?: CoverNodeWhereInput;
      orderBy?: CoverNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CoverNode>;
  coverNodesConnection: (
    args?: {
      where?: CoverNodeWhereInput;
      orderBy?: CoverNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CoverNodeConnectionPromise;
  exam: (where: ExamWhereUniqueInput) => ExamPromise;
  exams: (
    args?: {
      where?: ExamWhereInput;
      orderBy?: ExamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Exam>;
  examsConnection: (
    args?: {
      where?: ExamWhereInput;
      orderBy?: ExamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExamConnectionPromise;
  explanationNode: (
    where: ExplanationNodeWhereUniqueInput
  ) => ExplanationNodePromise;
  explanationNodes: (
    args?: {
      where?: ExplanationNodeWhereInput;
      orderBy?: ExplanationNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExplanationNode>;
  explanationNodesConnection: (
    args?: {
      where?: ExplanationNodeWhereInput;
      orderBy?: ExplanationNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExplanationNodeConnectionPromise;
  question: (where: QuestionWhereUniqueInput) => QuestionPromise;
  questions: (
    args?: {
      where?: QuestionWhereInput;
      orderBy?: QuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Question>;
  questionsConnection: (
    args?: {
      where?: QuestionWhereInput;
      orderBy?: QuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => QuestionConnectionPromise;
  questionNode: (where: QuestionNodeWhereUniqueInput) => QuestionNodePromise;
  questionNodes: (
    args?: {
      where?: QuestionNodeWhereInput;
      orderBy?: QuestionNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<QuestionNode>;
  questionNodesConnection: (
    args?: {
      where?: QuestionNodeWhereInput;
      orderBy?: QuestionNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => QuestionNodeConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createChoice: (data: ChoiceCreateInput) => ChoicePromise;
  updateChoice: (
    args: { data: ChoiceUpdateInput; where: ChoiceWhereUniqueInput }
  ) => ChoicePromise;
  updateManyChoices: (
    args: { data: ChoiceUpdateManyMutationInput; where?: ChoiceWhereInput }
  ) => BatchPayloadPromise;
  upsertChoice: (
    args: {
      where: ChoiceWhereUniqueInput;
      create: ChoiceCreateInput;
      update: ChoiceUpdateInput;
    }
  ) => ChoicePromise;
  deleteChoice: (where: ChoiceWhereUniqueInput) => ChoicePromise;
  deleteManyChoices: (where?: ChoiceWhereInput) => BatchPayloadPromise;
  createCoverNode: (data: CoverNodeCreateInput) => CoverNodePromise;
  updateCoverNode: (
    args: { data: CoverNodeUpdateInput; where: CoverNodeWhereUniqueInput }
  ) => CoverNodePromise;
  updateManyCoverNodes: (
    args: {
      data: CoverNodeUpdateManyMutationInput;
      where?: CoverNodeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCoverNode: (
    args: {
      where: CoverNodeWhereUniqueInput;
      create: CoverNodeCreateInput;
      update: CoverNodeUpdateInput;
    }
  ) => CoverNodePromise;
  deleteCoverNode: (where: CoverNodeWhereUniqueInput) => CoverNodePromise;
  deleteManyCoverNodes: (where?: CoverNodeWhereInput) => BatchPayloadPromise;
  createExam: (data: ExamCreateInput) => ExamPromise;
  updateExam: (
    args: { data: ExamUpdateInput; where: ExamWhereUniqueInput }
  ) => ExamPromise;
  updateManyExams: (
    args: { data: ExamUpdateManyMutationInput; where?: ExamWhereInput }
  ) => BatchPayloadPromise;
  upsertExam: (
    args: {
      where: ExamWhereUniqueInput;
      create: ExamCreateInput;
      update: ExamUpdateInput;
    }
  ) => ExamPromise;
  deleteExam: (where: ExamWhereUniqueInput) => ExamPromise;
  deleteManyExams: (where?: ExamWhereInput) => BatchPayloadPromise;
  createExplanationNode: (
    data: ExplanationNodeCreateInput
  ) => ExplanationNodePromise;
  updateExplanationNode: (
    args: {
      data: ExplanationNodeUpdateInput;
      where: ExplanationNodeWhereUniqueInput;
    }
  ) => ExplanationNodePromise;
  updateManyExplanationNodes: (
    args: {
      data: ExplanationNodeUpdateManyMutationInput;
      where?: ExplanationNodeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertExplanationNode: (
    args: {
      where: ExplanationNodeWhereUniqueInput;
      create: ExplanationNodeCreateInput;
      update: ExplanationNodeUpdateInput;
    }
  ) => ExplanationNodePromise;
  deleteExplanationNode: (
    where: ExplanationNodeWhereUniqueInput
  ) => ExplanationNodePromise;
  deleteManyExplanationNodes: (
    where?: ExplanationNodeWhereInput
  ) => BatchPayloadPromise;
  createQuestion: (data: QuestionCreateInput) => QuestionPromise;
  updateQuestion: (
    args: { data: QuestionUpdateInput; where: QuestionWhereUniqueInput }
  ) => QuestionPromise;
  updateManyQuestions: (
    args: { data: QuestionUpdateManyMutationInput; where?: QuestionWhereInput }
  ) => BatchPayloadPromise;
  upsertQuestion: (
    args: {
      where: QuestionWhereUniqueInput;
      create: QuestionCreateInput;
      update: QuestionUpdateInput;
    }
  ) => QuestionPromise;
  deleteQuestion: (where: QuestionWhereUniqueInput) => QuestionPromise;
  deleteManyQuestions: (where?: QuestionWhereInput) => BatchPayloadPromise;
  createQuestionNode: (data: QuestionNodeCreateInput) => QuestionNodePromise;
  updateQuestionNode: (
    args: { data: QuestionNodeUpdateInput; where: QuestionNodeWhereUniqueInput }
  ) => QuestionNodePromise;
  updateManyQuestionNodes: (
    args: {
      data: QuestionNodeUpdateManyMutationInput;
      where?: QuestionNodeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertQuestionNode: (
    args: {
      where: QuestionNodeWhereUniqueInput;
      create: QuestionNodeCreateInput;
      update: QuestionNodeUpdateInput;
    }
  ) => QuestionNodePromise;
  deleteQuestionNode: (
    where: QuestionNodeWhereUniqueInput
  ) => QuestionNodePromise;
  deleteManyQuestionNodes: (
    where?: QuestionNodeWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  choice: (
    where?: ChoiceSubscriptionWhereInput
  ) => ChoiceSubscriptionPayloadSubscription;
  coverNode: (
    where?: CoverNodeSubscriptionWhereInput
  ) => CoverNodeSubscriptionPayloadSubscription;
  exam: (
    where?: ExamSubscriptionWhereInput
  ) => ExamSubscriptionPayloadSubscription;
  explanationNode: (
    where?: ExplanationNodeSubscriptionWhereInput
  ) => ExplanationNodeSubscriptionPayloadSubscription;
  question: (
    where?: QuestionSubscriptionWhereInput
  ) => QuestionSubscriptionPayloadSubscription;
  questionNode: (
    where?: QuestionNodeSubscriptionWhereInput
  ) => QuestionNodeSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CoverNodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "variant_ASC"
  | "variant_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type QuestionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "variant_ASC"
  | "variant_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type QuestionNodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "variant_ASC"
  | "variant_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExplanationNodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "variant_ASC"
  | "variant_DESC"
  | "text_ASC"
  | "text_DESC"
  | "href_ASC"
  | "href_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Role = "USER" | "ADMIN";

export type ChoiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "label_ASC"
  | "label_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "published_ASC"
  | "published_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "code_ASC"
  | "code_DESC"
  | "pass_ASC"
  | "pass_DESC"
  | "time_ASC"
  | "time_DESC"
  | "image_ASC"
  | "image_DESC"
  | "downloads_ASC"
  | "downloads_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "googleID_ASC"
  | "googleID_DESC"
  | "name_ASC"
  | "name_DESC"
  | "password_ASC"
  | "password_DESC"
  | "email_ASC"
  | "email_DESC"
  | "image_ASC"
  | "image_DESC"
  | "homepage_ASC"
  | "homepage_DESC"
  | "role_ASC"
  | "role_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface CoverNodeUpdateWithWhereUniqueNestedInput {
  where: CoverNodeWhereUniqueInput;
  data: CoverNodeUpdateDataInput;
}

export type ChoiceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface QuestionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  variant?: Int;
  variant_not?: Int;
  variant_in?: Int[] | Int;
  variant_not_in?: Int[] | Int;
  variant_lt?: Int;
  variant_lte?: Int;
  variant_gt?: Int;
  variant_gte?: Int;
  AND?: QuestionScalarWhereInput[] | QuestionScalarWhereInput;
  OR?: QuestionScalarWhereInput[] | QuestionScalarWhereInput;
  NOT?: QuestionScalarWhereInput[] | QuestionScalarWhereInput;
}

export interface ExplanationNodeUpdateManyWithWhereNestedInput {
  where: ExplanationNodeScalarWhereInput;
  data: ExplanationNodeUpdateManyDataInput;
}

export interface QuestionUpsertWithWhereUniqueNestedInput {
  where: QuestionWhereUniqueInput;
  update: QuestionUpdateDataInput;
  create: QuestionCreateInput;
}

export interface CoverNodeUpdateManyDataInput {
  variant?: Int;
  text?: String;
}

export interface CoverNodeCreateInput {
  variant?: Int;
  text?: String;
}

export interface CoverNodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  variant?: Int;
  variant_not?: Int;
  variant_in?: Int[] | Int;
  variant_not_in?: Int[] | Int;
  variant_lt?: Int;
  variant_lte?: Int;
  variant_gt?: Int;
  variant_gte?: Int;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: CoverNodeWhereInput[] | CoverNodeWhereInput;
  OR?: CoverNodeWhereInput[] | CoverNodeWhereInput;
  NOT?: CoverNodeWhereInput[] | CoverNodeWhereInput;
}

export interface CoverNodeUpdateInput {
  variant?: Int;
  text?: String;
}

export interface QuestionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: QuestionWhereInput;
  AND?: QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput;
  OR?: QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput;
  NOT?: QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput;
}

export interface CoverNodeUpdateManyMutationInput {
  variant?: Int;
  text?: String;
}

export interface ExamSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExamWhereInput;
  AND?: ExamSubscriptionWhereInput[] | ExamSubscriptionWhereInput;
  OR?: ExamSubscriptionWhereInput[] | ExamSubscriptionWhereInput;
  NOT?: ExamSubscriptionWhereInput[] | ExamSubscriptionWhereInput;
}

export interface ExamCreateInput {
  published?: Boolean;
  title: String;
  description?: String;
  code?: String;
  pass?: Int;
  time?: Int;
  image?: String;
  downloads?: Int;
  cover?: CoverNodeCreateManyInput;
  test?: QuestionCreateManyInput;
  user?: UserCreateOneWithoutExamsInput;
}

export interface CoverNodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CoverNodeWhereInput;
  AND?: CoverNodeSubscriptionWhereInput[] | CoverNodeSubscriptionWhereInput;
  OR?: CoverNodeSubscriptionWhereInput[] | CoverNodeSubscriptionWhereInput;
  NOT?: CoverNodeSubscriptionWhereInput[] | CoverNodeSubscriptionWhereInput;
}

export interface CoverNodeCreateManyInput {
  create?: CoverNodeCreateInput[] | CoverNodeCreateInput;
  connect?: CoverNodeWhereUniqueInput[] | CoverNodeWhereUniqueInput;
}

export interface QuestionNodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  variant?: Int;
  variant_not?: Int;
  variant_in?: Int[] | Int;
  variant_not_in?: Int[] | Int;
  variant_lt?: Int;
  variant_lte?: Int;
  variant_gt?: Int;
  variant_gte?: Int;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: QuestionNodeWhereInput[] | QuestionNodeWhereInput;
  OR?: QuestionNodeWhereInput[] | QuestionNodeWhereInput;
  NOT?: QuestionNodeWhereInput[] | QuestionNodeWhereInput;
}

export interface QuestionCreateManyInput {
  create?: QuestionCreateInput[] | QuestionCreateInput;
  connect?: QuestionWhereUniqueInput[] | QuestionWhereUniqueInput;
}

export interface ChoiceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ChoiceWhereInput;
  AND?: ChoiceSubscriptionWhereInput[] | ChoiceSubscriptionWhereInput;
  OR?: ChoiceSubscriptionWhereInput[] | ChoiceSubscriptionWhereInput;
  NOT?: ChoiceSubscriptionWhereInput[] | ChoiceSubscriptionWhereInput;
}

export interface QuestionCreateInput {
  variant?: Int;
  question?: QuestionNodeCreateManyInput;
  choices?: ChoiceCreateManyInput;
  answer?: QuestionCreateanswerInput;
  explanation?: ExplanationNodeCreateManyInput;
}

export interface ExamUpdateManyDataInput {
  published?: Boolean;
  title?: String;
  description?: String;
  code?: String;
  pass?: Int;
  time?: Int;
  image?: String;
  downloads?: Int;
}

export interface QuestionNodeCreateManyInput {
  create?: QuestionNodeCreateInput[] | QuestionNodeCreateInput;
  connect?: QuestionNodeWhereUniqueInput[] | QuestionNodeWhereUniqueInput;
}

export interface ExamScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  published?: Boolean;
  published_not?: Boolean;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  pass?: Int;
  pass_not?: Int;
  pass_in?: Int[] | Int;
  pass_not_in?: Int[] | Int;
  pass_lt?: Int;
  pass_lte?: Int;
  pass_gt?: Int;
  pass_gte?: Int;
  time?: Int;
  time_not?: Int;
  time_in?: Int[] | Int;
  time_not_in?: Int[] | Int;
  time_lt?: Int;
  time_lte?: Int;
  time_gt?: Int;
  time_gte?: Int;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  downloads?: Int;
  downloads_not?: Int;
  downloads_in?: Int[] | Int;
  downloads_not_in?: Int[] | Int;
  downloads_lt?: Int;
  downloads_lte?: Int;
  downloads_gt?: Int;
  downloads_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: ExamScalarWhereInput[] | ExamScalarWhereInput;
  OR?: ExamScalarWhereInput[] | ExamScalarWhereInput;
  NOT?: ExamScalarWhereInput[] | ExamScalarWhereInput;
}

export interface QuestionNodeCreateInput {
  variant?: Int;
  text?: String;
}

export interface ExamUpdateWithoutUserDataInput {
  published?: Boolean;
  title?: String;
  description?: String;
  code?: String;
  pass?: Int;
  time?: Int;
  image?: String;
  downloads?: Int;
  cover?: CoverNodeUpdateManyInput;
  test?: QuestionUpdateManyInput;
}

export interface ChoiceCreateManyInput {
  create?: ChoiceCreateInput[] | ChoiceCreateInput;
  connect?: ChoiceWhereUniqueInput[] | ChoiceWhereUniqueInput;
}

export interface ExamWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  published?: Boolean;
  published_not?: Boolean;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  pass?: Int;
  pass_not?: Int;
  pass_in?: Int[] | Int;
  pass_not_in?: Int[] | Int;
  pass_lt?: Int;
  pass_lte?: Int;
  pass_gt?: Int;
  pass_gte?: Int;
  time?: Int;
  time_not?: Int;
  time_in?: Int[] | Int;
  time_not_in?: Int[] | Int;
  time_lt?: Int;
  time_lte?: Int;
  time_gt?: Int;
  time_gte?: Int;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  downloads?: Int;
  downloads_not?: Int;
  downloads_in?: Int[] | Int;
  downloads_not_in?: Int[] | Int;
  downloads_lt?: Int;
  downloads_lte?: Int;
  downloads_gt?: Int;
  downloads_gte?: Int;
  cover_every?: CoverNodeWhereInput;
  cover_some?: CoverNodeWhereInput;
  cover_none?: CoverNodeWhereInput;
  test_every?: QuestionWhereInput;
  test_some?: QuestionWhereInput;
  test_none?: QuestionWhereInput;
  user?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: ExamWhereInput[] | ExamWhereInput;
  OR?: ExamWhereInput[] | ExamWhereInput;
  NOT?: ExamWhereInput[] | ExamWhereInput;
}

export interface QuestionCreateanswerInput {
  set?: Boolean[] | Boolean;
}

export interface ExamUpdateManyWithoutUserInput {
  create?: ExamCreateWithoutUserInput[] | ExamCreateWithoutUserInput;
  delete?: ExamWhereUniqueInput[] | ExamWhereUniqueInput;
  connect?: ExamWhereUniqueInput[] | ExamWhereUniqueInput;
  set?: ExamWhereUniqueInput[] | ExamWhereUniqueInput;
  disconnect?: ExamWhereUniqueInput[] | ExamWhereUniqueInput;
  update?:
    | ExamUpdateWithWhereUniqueWithoutUserInput[]
    | ExamUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | ExamUpsertWithWhereUniqueWithoutUserInput[]
    | ExamUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: ExamScalarWhereInput[] | ExamScalarWhereInput;
  updateMany?:
    | ExamUpdateManyWithWhereNestedInput[]
    | ExamUpdateManyWithWhereNestedInput;
}

export interface ExplanationNodeCreateManyInput {
  create?: ExplanationNodeCreateInput[] | ExplanationNodeCreateInput;
  connect?: ExplanationNodeWhereUniqueInput[] | ExplanationNodeWhereUniqueInput;
}

export interface UserUpdateInput {
  googleID?: String;
  name?: String;
  password?: String;
  email?: String;
  image?: String;
  homepage?: String;
  role?: Role;
  exams?: ExamUpdateManyWithoutUserInput;
}

export interface ExplanationNodeCreateInput {
  variant?: Int;
  text?: String;
  href?: String;
}

export interface ExamCreateManyWithoutUserInput {
  create?: ExamCreateWithoutUserInput[] | ExamCreateWithoutUserInput;
  connect?: ExamWhereUniqueInput[] | ExamWhereUniqueInput;
}

export interface UserCreateOneWithoutExamsInput {
  create?: UserCreateWithoutExamsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateInput {
  googleID?: String;
  name: String;
  password?: String;
  email?: String;
  image?: String;
  homepage?: String;
  role?: Role;
  exams?: ExamCreateManyWithoutUserInput;
}

export interface UserCreateWithoutExamsInput {
  googleID?: String;
  name: String;
  password?: String;
  email?: String;
  image?: String;
  homepage?: String;
  role?: Role;
}

export interface QuestionNodeUpdateInput {
  variant?: Int;
  text?: String;
}

export interface ExamUpdateInput {
  published?: Boolean;
  title?: String;
  description?: String;
  code?: String;
  pass?: Int;
  time?: Int;
  image?: String;
  downloads?: Int;
  cover?: CoverNodeUpdateManyInput;
  test?: QuestionUpdateManyInput;
  user?: UserUpdateOneWithoutExamsInput;
}

export interface QuestionUpdateManyMutationInput {
  variant?: Int;
  answer?: QuestionUpdateanswerInput;
}

export interface CoverNodeUpdateManyInput {
  create?: CoverNodeCreateInput[] | CoverNodeCreateInput;
  update?:
    | CoverNodeUpdateWithWhereUniqueNestedInput[]
    | CoverNodeUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CoverNodeUpsertWithWhereUniqueNestedInput[]
    | CoverNodeUpsertWithWhereUniqueNestedInput;
  delete?: CoverNodeWhereUniqueInput[] | CoverNodeWhereUniqueInput;
  connect?: CoverNodeWhereUniqueInput[] | CoverNodeWhereUniqueInput;
  set?: CoverNodeWhereUniqueInput[] | CoverNodeWhereUniqueInput;
  disconnect?: CoverNodeWhereUniqueInput[] | CoverNodeWhereUniqueInput;
  deleteMany?: CoverNodeScalarWhereInput[] | CoverNodeScalarWhereInput;
  updateMany?:
    | CoverNodeUpdateManyWithWhereNestedInput[]
    | CoverNodeUpdateManyWithWhereNestedInput;
}

export interface ExplanationNodeUpdateManyMutationInput {
  variant?: Int;
  text?: String;
  href?: String;
}

export interface ExplanationNodeUpdateManyDataInput {
  variant?: Int;
  text?: String;
  href?: String;
}

export interface ExplanationNodeUpdateInput {
  variant?: Int;
  text?: String;
  href?: String;
}

export interface CoverNodeUpdateDataInput {
  variant?: Int;
  text?: String;
}

export interface UserUpsertWithoutExamsInput {
  update: UserUpdateWithoutExamsDataInput;
  create: UserCreateWithoutExamsInput;
}

export interface CoverNodeUpsertWithWhereUniqueNestedInput {
  where: CoverNodeWhereUniqueInput;
  update: CoverNodeUpdateDataInput;
  create: CoverNodeCreateInput;
}

export interface UserUpdateWithoutExamsDataInput {
  googleID?: String;
  name?: String;
  password?: String;
  email?: String;
  image?: String;
  homepage?: String;
  role?: Role;
}

export interface CoverNodeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  variant?: Int;
  variant_not?: Int;
  variant_in?: Int[] | Int;
  variant_not_in?: Int[] | Int;
  variant_lt?: Int;
  variant_lte?: Int;
  variant_gt?: Int;
  variant_gte?: Int;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: CoverNodeScalarWhereInput[] | CoverNodeScalarWhereInput;
  OR?: CoverNodeScalarWhereInput[] | CoverNodeScalarWhereInput;
  NOT?: CoverNodeScalarWhereInput[] | CoverNodeScalarWhereInput;
}

export interface QuestionUpdateManyDataInput {
  variant?: Int;
  answer?: QuestionUpdateanswerInput;
}

export interface CoverNodeUpdateManyWithWhereNestedInput {
  where: CoverNodeScalarWhereInput;
  data: CoverNodeUpdateManyDataInput;
}

export interface ChoiceUpdateInput {
  label?: String;
  text?: String;
}

export type CoverNodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface QuestionUpdateManyInput {
  create?: QuestionCreateInput[] | QuestionCreateInput;
  update?:
    | QuestionUpdateWithWhereUniqueNestedInput[]
    | QuestionUpdateWithWhereUniqueNestedInput;
  upsert?:
    | QuestionUpsertWithWhereUniqueNestedInput[]
    | QuestionUpsertWithWhereUniqueNestedInput;
  delete?: QuestionWhereUniqueInput[] | QuestionWhereUniqueInput;
  connect?: QuestionWhereUniqueInput[] | QuestionWhereUniqueInput;
  set?: QuestionWhereUniqueInput[] | QuestionWhereUniqueInput;
  disconnect?: QuestionWhereUniqueInput[] | QuestionWhereUniqueInput;
  deleteMany?: QuestionScalarWhereInput[] | QuestionScalarWhereInput;
  updateMany?:
    | QuestionUpdateManyWithWhereNestedInput[]
    | QuestionUpdateManyWithWhereNestedInput;
}

export interface ExplanationNodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExplanationNodeWhereInput;
  AND?:
    | ExplanationNodeSubscriptionWhereInput[]
    | ExplanationNodeSubscriptionWhereInput;
  OR?:
    | ExplanationNodeSubscriptionWhereInput[]
    | ExplanationNodeSubscriptionWhereInput;
  NOT?:
    | ExplanationNodeSubscriptionWhereInput[]
    | ExplanationNodeSubscriptionWhereInput;
}

export interface QuestionUpdateWithWhereUniqueNestedInput {
  where: QuestionWhereUniqueInput;
  data: QuestionUpdateDataInput;
}

export interface QuestionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  variant?: Int;
  variant_not?: Int;
  variant_in?: Int[] | Int;
  variant_not_in?: Int[] | Int;
  variant_lt?: Int;
  variant_lte?: Int;
  variant_gt?: Int;
  variant_gte?: Int;
  question_every?: QuestionNodeWhereInput;
  question_some?: QuestionNodeWhereInput;
  question_none?: QuestionNodeWhereInput;
  choices_every?: ChoiceWhereInput;
  choices_some?: ChoiceWhereInput;
  choices_none?: ChoiceWhereInput;
  explanation_every?: ExplanationNodeWhereInput;
  explanation_some?: ExplanationNodeWhereInput;
  explanation_none?: ExplanationNodeWhereInput;
  AND?: QuestionWhereInput[] | QuestionWhereInput;
  OR?: QuestionWhereInput[] | QuestionWhereInput;
  NOT?: QuestionWhereInput[] | QuestionWhereInput;
}

export interface QuestionUpdateDataInput {
  variant?: Int;
  question?: QuestionNodeUpdateManyInput;
  choices?: ChoiceUpdateManyInput;
  answer?: QuestionUpdateanswerInput;
  explanation?: ExplanationNodeUpdateManyInput;
}

export interface UserUpdateManyMutationInput {
  googleID?: String;
  name?: String;
  password?: String;
  email?: String;
  image?: String;
  homepage?: String;
  role?: Role;
}

export interface QuestionNodeUpdateManyInput {
  create?: QuestionNodeCreateInput[] | QuestionNodeCreateInput;
  update?:
    | QuestionNodeUpdateWithWhereUniqueNestedInput[]
    | QuestionNodeUpdateWithWhereUniqueNestedInput;
  upsert?:
    | QuestionNodeUpsertWithWhereUniqueNestedInput[]
    | QuestionNodeUpsertWithWhereUniqueNestedInput;
  delete?: QuestionNodeWhereUniqueInput[] | QuestionNodeWhereUniqueInput;
  connect?: QuestionNodeWhereUniqueInput[] | QuestionNodeWhereUniqueInput;
  set?: QuestionNodeWhereUniqueInput[] | QuestionNodeWhereUniqueInput;
  disconnect?: QuestionNodeWhereUniqueInput[] | QuestionNodeWhereUniqueInput;
  deleteMany?: QuestionNodeScalarWhereInput[] | QuestionNodeScalarWhereInput;
  updateMany?:
    | QuestionNodeUpdateManyWithWhereNestedInput[]
    | QuestionNodeUpdateManyWithWhereNestedInput;
}

export interface ExamUpsertWithWhereUniqueWithoutUserInput {
  where: ExamWhereUniqueInput;
  update: ExamUpdateWithoutUserDataInput;
  create: ExamCreateWithoutUserInput;
}

export interface QuestionNodeUpdateWithWhereUniqueNestedInput {
  where: QuestionNodeWhereUniqueInput;
  data: QuestionNodeUpdateDataInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  googleID?: String;
  googleID_not?: String;
  googleID_in?: String[] | String;
  googleID_not_in?: String[] | String;
  googleID_lt?: String;
  googleID_lte?: String;
  googleID_gt?: String;
  googleID_gte?: String;
  googleID_contains?: String;
  googleID_not_contains?: String;
  googleID_starts_with?: String;
  googleID_not_starts_with?: String;
  googleID_ends_with?: String;
  googleID_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  homepage?: String;
  homepage_not?: String;
  homepage_in?: String[] | String;
  homepage_not_in?: String[] | String;
  homepage_lt?: String;
  homepage_lte?: String;
  homepage_gt?: String;
  homepage_gte?: String;
  homepage_contains?: String;
  homepage_not_contains?: String;
  homepage_starts_with?: String;
  homepage_not_starts_with?: String;
  homepage_ends_with?: String;
  homepage_not_ends_with?: String;
  role?: Role;
  role_not?: Role;
  role_in?: Role[] | Role;
  role_not_in?: Role[] | Role;
  exams_every?: ExamWhereInput;
  exams_some?: ExamWhereInput;
  exams_none?: ExamWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface QuestionNodeUpdateDataInput {
  variant?: Int;
  text?: String;
}

export interface ExamCreateWithoutUserInput {
  published?: Boolean;
  title: String;
  description?: String;
  code?: String;
  pass?: Int;
  time?: Int;
  image?: String;
  downloads?: Int;
  cover?: CoverNodeCreateManyInput;
  test?: QuestionCreateManyInput;
}

export interface QuestionNodeUpsertWithWhereUniqueNestedInput {
  where: QuestionNodeWhereUniqueInput;
  update: QuestionNodeUpdateDataInput;
  create: QuestionNodeCreateInput;
}

export interface QuestionNodeUpdateManyMutationInput {
  variant?: Int;
  text?: String;
}

export interface QuestionNodeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  variant?: Int;
  variant_not?: Int;
  variant_in?: Int[] | Int;
  variant_not_in?: Int[] | Int;
  variant_lt?: Int;
  variant_lte?: Int;
  variant_gt?: Int;
  variant_gte?: Int;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: QuestionNodeScalarWhereInput[] | QuestionNodeScalarWhereInput;
  OR?: QuestionNodeScalarWhereInput[] | QuestionNodeScalarWhereInput;
  NOT?: QuestionNodeScalarWhereInput[] | QuestionNodeScalarWhereInput;
}

export interface QuestionUpdateInput {
  variant?: Int;
  question?: QuestionNodeUpdateManyInput;
  choices?: ChoiceUpdateManyInput;
  answer?: QuestionUpdateanswerInput;
  explanation?: ExplanationNodeUpdateManyInput;
}

export interface QuestionNodeUpdateManyWithWhereNestedInput {
  where: QuestionNodeScalarWhereInput;
  data: QuestionNodeUpdateManyDataInput;
}

export interface ExamUpdateManyMutationInput {
  published?: Boolean;
  title?: String;
  description?: String;
  code?: String;
  pass?: Int;
  time?: Int;
  image?: String;
  downloads?: Int;
}

export interface QuestionNodeUpdateManyDataInput {
  variant?: Int;
  text?: String;
}

export interface UserUpdateOneWithoutExamsInput {
  create?: UserCreateWithoutExamsInput;
  update?: UserUpdateWithoutExamsDataInput;
  upsert?: UserUpsertWithoutExamsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface ChoiceUpdateManyInput {
  create?: ChoiceCreateInput[] | ChoiceCreateInput;
  update?:
    | ChoiceUpdateWithWhereUniqueNestedInput[]
    | ChoiceUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ChoiceUpsertWithWhereUniqueNestedInput[]
    | ChoiceUpsertWithWhereUniqueNestedInput;
  delete?: ChoiceWhereUniqueInput[] | ChoiceWhereUniqueInput;
  connect?: ChoiceWhereUniqueInput[] | ChoiceWhereUniqueInput;
  set?: ChoiceWhereUniqueInput[] | ChoiceWhereUniqueInput;
  disconnect?: ChoiceWhereUniqueInput[] | ChoiceWhereUniqueInput;
  deleteMany?: ChoiceScalarWhereInput[] | ChoiceScalarWhereInput;
  updateMany?:
    | ChoiceUpdateManyWithWhereNestedInput[]
    | ChoiceUpdateManyWithWhereNestedInput;
}

export interface ChoiceCreateInput {
  label?: String;
  text?: String;
}

export interface ChoiceUpdateWithWhereUniqueNestedInput {
  where: ChoiceWhereUniqueInput;
  data: ChoiceUpdateDataInput;
}

export interface QuestionNodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: QuestionNodeWhereInput;
  AND?:
    | QuestionNodeSubscriptionWhereInput[]
    | QuestionNodeSubscriptionWhereInput;
  OR?:
    | QuestionNodeSubscriptionWhereInput[]
    | QuestionNodeSubscriptionWhereInput;
  NOT?:
    | QuestionNodeSubscriptionWhereInput[]
    | QuestionNodeSubscriptionWhereInput;
}

export interface ChoiceUpdateDataInput {
  label?: String;
  text?: String;
}

export interface ExplanationNodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  variant?: Int;
  variant_not?: Int;
  variant_in?: Int[] | Int;
  variant_not_in?: Int[] | Int;
  variant_lt?: Int;
  variant_lte?: Int;
  variant_gt?: Int;
  variant_gte?: Int;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  href?: String;
  href_not?: String;
  href_in?: String[] | String;
  href_not_in?: String[] | String;
  href_lt?: String;
  href_lte?: String;
  href_gt?: String;
  href_gte?: String;
  href_contains?: String;
  href_not_contains?: String;
  href_starts_with?: String;
  href_not_starts_with?: String;
  href_ends_with?: String;
  href_not_ends_with?: String;
  AND?: ExplanationNodeWhereInput[] | ExplanationNodeWhereInput;
  OR?: ExplanationNodeWhereInput[] | ExplanationNodeWhereInput;
  NOT?: ExplanationNodeWhereInput[] | ExplanationNodeWhereInput;
}

export interface ChoiceUpsertWithWhereUniqueNestedInput {
  where: ChoiceWhereUniqueInput;
  update: ChoiceUpdateDataInput;
  create: ChoiceCreateInput;
}

export interface ExamUpdateWithWhereUniqueWithoutUserInput {
  where: ExamWhereUniqueInput;
  data: ExamUpdateWithoutUserDataInput;
}

export interface ChoiceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: ChoiceScalarWhereInput[] | ChoiceScalarWhereInput;
  OR?: ChoiceScalarWhereInput[] | ChoiceScalarWhereInput;
  NOT?: ChoiceScalarWhereInput[] | ChoiceScalarWhereInput;
}

export type ExplanationNodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ChoiceUpdateManyWithWhereNestedInput {
  where: ChoiceScalarWhereInput;
  data: ChoiceUpdateManyDataInput;
}

export type QuestionNodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ChoiceUpdateManyDataInput {
  label?: String;
  text?: String;
}

export interface QuestionUpdateManyWithWhereNestedInput {
  where: QuestionScalarWhereInput;
  data: QuestionUpdateManyDataInput;
}

export interface QuestionUpdateanswerInput {
  set?: Boolean[] | Boolean;
}

export type ExamWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExplanationNodeUpdateManyInput {
  create?: ExplanationNodeCreateInput[] | ExplanationNodeCreateInput;
  update?:
    | ExplanationNodeUpdateWithWhereUniqueNestedInput[]
    | ExplanationNodeUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ExplanationNodeUpsertWithWhereUniqueNestedInput[]
    | ExplanationNodeUpsertWithWhereUniqueNestedInput;
  delete?: ExplanationNodeWhereUniqueInput[] | ExplanationNodeWhereUniqueInput;
  connect?: ExplanationNodeWhereUniqueInput[] | ExplanationNodeWhereUniqueInput;
  set?: ExplanationNodeWhereUniqueInput[] | ExplanationNodeWhereUniqueInput;
  disconnect?:
    | ExplanationNodeWhereUniqueInput[]
    | ExplanationNodeWhereUniqueInput;
  deleteMany?:
    | ExplanationNodeScalarWhereInput[]
    | ExplanationNodeScalarWhereInput;
  updateMany?:
    | ExplanationNodeUpdateManyWithWhereNestedInput[]
    | ExplanationNodeUpdateManyWithWhereNestedInput;
}

export interface ChoiceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: ChoiceWhereInput[] | ChoiceWhereInput;
  OR?: ChoiceWhereInput[] | ChoiceWhereInput;
  NOT?: ChoiceWhereInput[] | ChoiceWhereInput;
}

export interface ExplanationNodeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  variant?: Int;
  variant_not?: Int;
  variant_in?: Int[] | Int;
  variant_not_in?: Int[] | Int;
  variant_lt?: Int;
  variant_lte?: Int;
  variant_gt?: Int;
  variant_gte?: Int;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  href?: String;
  href_not?: String;
  href_in?: String[] | String;
  href_not_in?: String[] | String;
  href_lt?: String;
  href_lte?: String;
  href_gt?: String;
  href_gte?: String;
  href_contains?: String;
  href_not_contains?: String;
  href_starts_with?: String;
  href_not_starts_with?: String;
  href_ends_with?: String;
  href_not_ends_with?: String;
  AND?: ExplanationNodeScalarWhereInput[] | ExplanationNodeScalarWhereInput;
  OR?: ExplanationNodeScalarWhereInput[] | ExplanationNodeScalarWhereInput;
  NOT?: ExplanationNodeScalarWhereInput[] | ExplanationNodeScalarWhereInput;
}

export interface ExplanationNodeUpsertWithWhereUniqueNestedInput {
  where: ExplanationNodeWhereUniqueInput;
  update: ExplanationNodeUpdateDataInput;
  create: ExplanationNodeCreateInput;
}

export interface ExplanationNodeUpdateDataInput {
  variant?: Int;
  text?: String;
  href?: String;
}

export interface ExplanationNodeUpdateWithWhereUniqueNestedInput {
  where: ExplanationNodeWhereUniqueInput;
  data: ExplanationNodeUpdateDataInput;
}

export type QuestionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExamUpdateManyWithWhereNestedInput {
  where: ExamScalarWhereInput;
  data: ExamUpdateManyDataInput;
}

export interface ChoiceUpdateManyMutationInput {
  label?: String;
  text?: String;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  googleID?: String;
  email?: String;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  googleID?: String;
  name: String;
  password?: String;
  email?: String;
  image?: String;
  homepage?: String;
  role: Role;
  createdAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  googleID: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  image: () => Promise<String>;
  homepage: () => Promise<String>;
  role: () => Promise<Role>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  googleID: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  homepage: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface QuestionNode {
  id: ID_Output;
  variant: Int;
  text: String;
}

export interface QuestionNodePromise
  extends Promise<QuestionNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  variant: () => Promise<Int>;
  text: () => Promise<String>;
}

export interface QuestionNodeSubscription
  extends Promise<AsyncIterator<QuestionNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  variant: () => Promise<AsyncIterator<Int>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChoice {
  count: Int;
}

export interface AggregateChoicePromise
  extends Promise<AggregateChoice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChoiceSubscription
  extends Promise<AsyncIterator<AggregateChoice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Question {
  id: ID_Output;
  variant: Int;
  answer: Boolean[];
}

export interface QuestionPromise extends Promise<Question>, Fragmentable {
  id: () => Promise<ID_Output>;
  variant: () => Promise<Int>;
  question: <T = FragmentableArray<QuestionNode>>(
    args?: {
      where?: QuestionNodeWhereInput;
      orderBy?: QuestionNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  choices: <T = FragmentableArray<Choice>>(
    args?: {
      where?: ChoiceWhereInput;
      orderBy?: ChoiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  answer: () => Promise<Boolean[]>;
  explanation: <T = FragmentableArray<ExplanationNode>>(
    args?: {
      where?: ExplanationNodeWhereInput;
      orderBy?: ExplanationNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface QuestionSubscription
  extends Promise<AsyncIterator<Question>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  variant: () => Promise<AsyncIterator<Int>>;
  question: <T = Promise<AsyncIterator<QuestionNodeSubscription>>>(
    args?: {
      where?: QuestionNodeWhereInput;
      orderBy?: QuestionNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  choices: <T = Promise<AsyncIterator<ChoiceSubscription>>>(
    args?: {
      where?: ChoiceWhereInput;
      orderBy?: ChoiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  answer: () => Promise<AsyncIterator<Boolean[]>>;
  explanation: <T = Promise<AsyncIterator<ExplanationNodeSubscription>>>(
    args?: {
      where?: ExplanationNodeWhereInput;
      orderBy?: ExplanationNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface QuestionNodeSubscriptionPayload {
  mutation: MutationType;
  node: QuestionNode;
  updatedFields: String[];
  previousValues: QuestionNodePreviousValues;
}

export interface QuestionNodeSubscriptionPayloadPromise
  extends Promise<QuestionNodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionNodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionNodePreviousValuesPromise>() => T;
}

export interface QuestionNodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionNodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionNodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionNodePreviousValuesSubscription>() => T;
}

export interface AggregateQuestionNode {
  count: Int;
}

export interface AggregateQuestionNodePromise
  extends Promise<AggregateQuestionNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionNodeSubscription
  extends Promise<AsyncIterator<AggregateQuestionNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionNodeConnection {
  pageInfo: PageInfo;
  edges: QuestionNodeEdge[];
}

export interface QuestionNodeConnectionPromise
  extends Promise<QuestionNodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionNodeEdge>>() => T;
  aggregate: <T = AggregateQuestionNodePromise>() => T;
}

export interface QuestionNodeConnectionSubscription
  extends Promise<AsyncIterator<QuestionNodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionNodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionNodeSubscription>() => T;
}

export interface Choice {
  id: ID_Output;
  label: String;
  text: String;
}

export interface ChoicePromise extends Promise<Choice>, Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  text: () => Promise<String>;
}

export interface ChoiceSubscription
  extends Promise<AsyncIterator<Choice>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface QuestionEdge {
  node: Question;
  cursor: String;
}

export interface QuestionEdgePromise
  extends Promise<QuestionEdge>,
    Fragmentable {
  node: <T = QuestionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionEdgeSubscription
  extends Promise<AsyncIterator<QuestionEdge>>,
    Fragmentable {
  node: <T = QuestionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ChoiceSubscriptionPayload {
  mutation: MutationType;
  node: Choice;
  updatedFields: String[];
  previousValues: ChoicePreviousValues;
}

export interface ChoiceSubscriptionPayloadPromise
  extends Promise<ChoiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChoicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChoicePreviousValuesPromise>() => T;
}

export interface ChoiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChoiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChoiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChoicePreviousValuesSubscription>() => T;
}

export interface AggregateExplanationNode {
  count: Int;
}

export interface AggregateExplanationNodePromise
  extends Promise<AggregateExplanationNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExplanationNodeSubscription
  extends Promise<AsyncIterator<AggregateExplanationNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChoicePreviousValues {
  id: ID_Output;
  label: String;
  text: String;
}

export interface ChoicePreviousValuesPromise
  extends Promise<ChoicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  text: () => Promise<String>;
}

export interface ChoicePreviousValuesSubscription
  extends Promise<AsyncIterator<ChoicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface ExplanationNodeConnection {
  pageInfo: PageInfo;
  edges: ExplanationNodeEdge[];
}

export interface ExplanationNodeConnectionPromise
  extends Promise<ExplanationNodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExplanationNodeEdge>>() => T;
  aggregate: <T = AggregateExplanationNodePromise>() => T;
}

export interface ExplanationNodeConnectionSubscription
  extends Promise<AsyncIterator<ExplanationNodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExplanationNodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExplanationNodeSubscription>() => T;
}

export interface Exam {
  id: ID_Output;
  published: Boolean;
  title: String;
  description?: String;
  code?: String;
  pass?: Int;
  time?: Int;
  image?: String;
  downloads?: Int;
  createdAt: DateTimeOutput;
}

export interface ExamPromise extends Promise<Exam>, Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  code: () => Promise<String>;
  pass: () => Promise<Int>;
  time: () => Promise<Int>;
  image: () => Promise<String>;
  downloads: () => Promise<Int>;
  cover: <T = FragmentableArray<CoverNode>>(
    args?: {
      where?: CoverNodeWhereInput;
      orderBy?: CoverNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  test: <T = FragmentableArray<Question>>(
    args?: {
      where?: QuestionWhereInput;
      orderBy?: QuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ExamSubscription
  extends Promise<AsyncIterator<Exam>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  pass: () => Promise<AsyncIterator<Int>>;
  time: () => Promise<AsyncIterator<Int>>;
  image: () => Promise<AsyncIterator<String>>;
  downloads: () => Promise<AsyncIterator<Int>>;
  cover: <T = Promise<AsyncIterator<CoverNodeSubscription>>>(
    args?: {
      where?: CoverNodeWhereInput;
      orderBy?: CoverNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  test: <T = Promise<AsyncIterator<QuestionSubscription>>>(
    args?: {
      where?: QuestionWhereInput;
      orderBy?: QuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExamEdge {
  node: Exam;
  cursor: String;
}

export interface ExamEdgePromise extends Promise<ExamEdge>, Fragmentable {
  node: <T = ExamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExamEdgeSubscription
  extends Promise<AsyncIterator<ExamEdge>>,
    Fragmentable {
  node: <T = ExamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CoverNodeSubscriptionPayload {
  mutation: MutationType;
  node: CoverNode;
  updatedFields: String[];
  previousValues: CoverNodePreviousValues;
}

export interface CoverNodeSubscriptionPayloadPromise
  extends Promise<CoverNodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CoverNodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CoverNodePreviousValuesPromise>() => T;
}

export interface CoverNodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CoverNodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CoverNodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CoverNodePreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface CoverNodePreviousValues {
  id: ID_Output;
  variant: Int;
  text: String;
}

export interface CoverNodePreviousValuesPromise
  extends Promise<CoverNodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  variant: () => Promise<Int>;
  text: () => Promise<String>;
}

export interface CoverNodePreviousValuesSubscription
  extends Promise<AsyncIterator<CoverNodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  variant: () => Promise<AsyncIterator<Int>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  googleID?: String;
  name: String;
  password?: String;
  email?: String;
  image?: String;
  homepage?: String;
  role: Role;
  createdAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  googleID: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  image: () => Promise<String>;
  homepage: () => Promise<String>;
  role: () => Promise<Role>;
  exams: <T = FragmentableArray<Exam>>(
    args?: {
      where?: ExamWhereInput;
      orderBy?: ExamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  googleID: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  homepage: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  exams: <T = Promise<AsyncIterator<ExamSubscription>>>(
    args?: {
      where?: ExamWhereInput;
      orderBy?: ExamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateCoverNode {
  count: Int;
}

export interface AggregateCoverNodePromise
  extends Promise<AggregateCoverNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCoverNodeSubscription
  extends Promise<AsyncIterator<AggregateCoverNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChoiceConnection {
  pageInfo: PageInfo;
  edges: ChoiceEdge[];
}

export interface ChoiceConnectionPromise
  extends Promise<ChoiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChoiceEdge>>() => T;
  aggregate: <T = AggregateChoicePromise>() => T;
}

export interface ChoiceConnectionSubscription
  extends Promise<AsyncIterator<ChoiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChoiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChoiceSubscription>() => T;
}

export interface ExamSubscriptionPayload {
  mutation: MutationType;
  node: Exam;
  updatedFields: String[];
  previousValues: ExamPreviousValues;
}

export interface ExamSubscriptionPayloadPromise
  extends Promise<ExamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExamPreviousValuesPromise>() => T;
}

export interface ExamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExamPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExamPreviousValues {
  id: ID_Output;
  published: Boolean;
  title: String;
  description?: String;
  code?: String;
  pass?: Int;
  time?: Int;
  image?: String;
  downloads?: Int;
  createdAt: DateTimeOutput;
}

export interface ExamPreviousValuesPromise
  extends Promise<ExamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  code: () => Promise<String>;
  pass: () => Promise<Int>;
  time: () => Promise<Int>;
  image: () => Promise<String>;
  downloads: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ExamPreviousValuesSubscription
  extends Promise<AsyncIterator<ExamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  pass: () => Promise<AsyncIterator<Int>>;
  time: () => Promise<AsyncIterator<Int>>;
  image: () => Promise<AsyncIterator<String>>;
  downloads: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateQuestion {
  count: Int;
}

export interface AggregateQuestionPromise
  extends Promise<AggregateQuestion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionSubscription
  extends Promise<AsyncIterator<AggregateQuestion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CoverNodeEdge {
  node: CoverNode;
  cursor: String;
}

export interface CoverNodeEdgePromise
  extends Promise<CoverNodeEdge>,
    Fragmentable {
  node: <T = CoverNodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CoverNodeEdgeSubscription
  extends Promise<AsyncIterator<CoverNodeEdge>>,
    Fragmentable {
  node: <T = CoverNodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExplanationNodeEdge {
  node: ExplanationNode;
  cursor: String;
}

export interface ExplanationNodeEdgePromise
  extends Promise<ExplanationNodeEdge>,
    Fragmentable {
  node: <T = ExplanationNodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExplanationNodeEdgeSubscription
  extends Promise<AsyncIterator<ExplanationNodeEdge>>,
    Fragmentable {
  node: <T = ExplanationNodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExplanationNodeSubscriptionPayload {
  mutation: MutationType;
  node: ExplanationNode;
  updatedFields: String[];
  previousValues: ExplanationNodePreviousValues;
}

export interface ExplanationNodeSubscriptionPayloadPromise
  extends Promise<ExplanationNodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExplanationNodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExplanationNodePreviousValuesPromise>() => T;
}

export interface ExplanationNodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExplanationNodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExplanationNodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExplanationNodePreviousValuesSubscription>() => T;
}

export interface ExamConnection {
  pageInfo: PageInfo;
  edges: ExamEdge[];
}

export interface ExamConnectionPromise
  extends Promise<ExamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExamEdge>>() => T;
  aggregate: <T = AggregateExamPromise>() => T;
}

export interface ExamConnectionSubscription
  extends Promise<AsyncIterator<ExamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExamSubscription>() => T;
}

export interface ExplanationNodePreviousValues {
  id: ID_Output;
  variant: Int;
  text: String;
  href?: String;
}

export interface ExplanationNodePreviousValuesPromise
  extends Promise<ExplanationNodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  variant: () => Promise<Int>;
  text: () => Promise<String>;
  href: () => Promise<String>;
}

export interface ExplanationNodePreviousValuesSubscription
  extends Promise<AsyncIterator<ExplanationNodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  variant: () => Promise<AsyncIterator<Int>>;
  text: () => Promise<AsyncIterator<String>>;
  href: () => Promise<AsyncIterator<String>>;
}

export interface ExplanationNode {
  id: ID_Output;
  variant: Int;
  text: String;
  href?: String;
}

export interface ExplanationNodePromise
  extends Promise<ExplanationNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  variant: () => Promise<Int>;
  text: () => Promise<String>;
  href: () => Promise<String>;
}

export interface ExplanationNodeSubscription
  extends Promise<AsyncIterator<ExplanationNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  variant: () => Promise<AsyncIterator<Int>>;
  text: () => Promise<AsyncIterator<String>>;
  href: () => Promise<AsyncIterator<String>>;
}

export interface ChoiceEdge {
  node: Choice;
  cursor: String;
}

export interface ChoiceEdgePromise extends Promise<ChoiceEdge>, Fragmentable {
  node: <T = ChoicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChoiceEdgeSubscription
  extends Promise<AsyncIterator<ChoiceEdge>>,
    Fragmentable {
  node: <T = ChoiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface QuestionPreviousValues {
  id: ID_Output;
  variant: Int;
  answer: Boolean[];
}

export interface QuestionPreviousValuesPromise
  extends Promise<QuestionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  variant: () => Promise<Int>;
  answer: () => Promise<Boolean[]>;
}

export interface QuestionPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  variant: () => Promise<AsyncIterator<Int>>;
  answer: () => Promise<AsyncIterator<Boolean[]>>;
}

export interface QuestionSubscriptionPayload {
  mutation: MutationType;
  node: Question;
  updatedFields: String[];
  previousValues: QuestionPreviousValues;
}

export interface QuestionSubscriptionPayloadPromise
  extends Promise<QuestionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionPreviousValuesPromise>() => T;
}

export interface QuestionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionPreviousValuesSubscription>() => T;
}

export interface CoverNodeConnection {
  pageInfo: PageInfo;
  edges: CoverNodeEdge[];
}

export interface CoverNodeConnectionPromise
  extends Promise<CoverNodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CoverNodeEdge>>() => T;
  aggregate: <T = AggregateCoverNodePromise>() => T;
}

export interface CoverNodeConnectionSubscription
  extends Promise<AsyncIterator<CoverNodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CoverNodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCoverNodeSubscription>() => T;
}

export interface QuestionNodePreviousValues {
  id: ID_Output;
  variant: Int;
  text: String;
}

export interface QuestionNodePreviousValuesPromise
  extends Promise<QuestionNodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  variant: () => Promise<Int>;
  text: () => Promise<String>;
}

export interface QuestionNodePreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionNodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  variant: () => Promise<AsyncIterator<Int>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface CoverNode {
  id: ID_Output;
  variant: Int;
  text: String;
}

export interface CoverNodePromise extends Promise<CoverNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  variant: () => Promise<Int>;
  text: () => Promise<String>;
}

export interface CoverNodeSubscription
  extends Promise<AsyncIterator<CoverNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  variant: () => Promise<AsyncIterator<Int>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExam {
  count: Int;
}

export interface AggregateExamPromise
  extends Promise<AggregateExam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExamSubscription
  extends Promise<AsyncIterator<AggregateExam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionConnection {
  pageInfo: PageInfo;
  edges: QuestionEdge[];
}

export interface QuestionConnectionPromise
  extends Promise<QuestionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionEdge>>() => T;
  aggregate: <T = AggregateQuestionPromise>() => T;
}

export interface QuestionConnectionSubscription
  extends Promise<AsyncIterator<QuestionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionSubscription>() => T;
}

export interface QuestionNodeEdge {
  node: QuestionNode;
  cursor: String;
}

export interface QuestionNodeEdgePromise
  extends Promise<QuestionNodeEdge>,
    Fragmentable {
  node: <T = QuestionNodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionNodeEdgeSubscription
  extends Promise<AsyncIterator<QuestionNodeEdge>>,
    Fragmentable {
  node: <T = QuestionNodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Exam",
    embedded: false
  },
  {
    name: "Question",
    embedded: false
  },
  {
    name: "CoverNode",
    embedded: false
  },
  {
    name: "Choice",
    embedded: false
  },
  {
    name: "QuestionNode",
    embedded: false
  },
  {
    name: "ExplanationNode",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
