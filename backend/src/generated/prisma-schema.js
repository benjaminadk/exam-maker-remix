module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.27.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateChoice {
  count: Int!
}

type AggregateCoverNode {
  count: Int!
}

type AggregateExam {
  count: Int!
}

type AggregateExplanationNode {
  count: Int!
}

type AggregateQuestion {
  count: Int!
}

type AggregateQuestionNode {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Choice {
  id: ID!
  label: String!
  text: String!
}

type ChoiceConnection {
  pageInfo: PageInfo!
  edges: [ChoiceEdge]!
  aggregate: AggregateChoice!
}

input ChoiceCreateInput {
  label: String
  text: String
}

input ChoiceCreateManyInput {
  create: [ChoiceCreateInput!]
  connect: [ChoiceWhereUniqueInput!]
}

type ChoiceEdge {
  node: Choice!
  cursor: String!
}

enum ChoiceOrderByInput {
  id_ASC
  id_DESC
  label_ASC
  label_DESC
  text_ASC
  text_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ChoicePreviousValues {
  id: ID!
  label: String!
  text: String!
}

input ChoiceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [ChoiceScalarWhereInput!]
  OR: [ChoiceScalarWhereInput!]
  NOT: [ChoiceScalarWhereInput!]
}

type ChoiceSubscriptionPayload {
  mutation: MutationType!
  node: Choice
  updatedFields: [String!]
  previousValues: ChoicePreviousValues
}

input ChoiceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChoiceWhereInput
  AND: [ChoiceSubscriptionWhereInput!]
  OR: [ChoiceSubscriptionWhereInput!]
  NOT: [ChoiceSubscriptionWhereInput!]
}

input ChoiceUpdateDataInput {
  label: String
  text: String
}

input ChoiceUpdateInput {
  label: String
  text: String
}

input ChoiceUpdateManyDataInput {
  label: String
  text: String
}

input ChoiceUpdateManyInput {
  create: [ChoiceCreateInput!]
  update: [ChoiceUpdateWithWhereUniqueNestedInput!]
  upsert: [ChoiceUpsertWithWhereUniqueNestedInput!]
  delete: [ChoiceWhereUniqueInput!]
  connect: [ChoiceWhereUniqueInput!]
  set: [ChoiceWhereUniqueInput!]
  disconnect: [ChoiceWhereUniqueInput!]
  deleteMany: [ChoiceScalarWhereInput!]
  updateMany: [ChoiceUpdateManyWithWhereNestedInput!]
}

input ChoiceUpdateManyMutationInput {
  label: String
  text: String
}

input ChoiceUpdateManyWithWhereNestedInput {
  where: ChoiceScalarWhereInput!
  data: ChoiceUpdateManyDataInput!
}

input ChoiceUpdateWithWhereUniqueNestedInput {
  where: ChoiceWhereUniqueInput!
  data: ChoiceUpdateDataInput!
}

input ChoiceUpsertWithWhereUniqueNestedInput {
  where: ChoiceWhereUniqueInput!
  update: ChoiceUpdateDataInput!
  create: ChoiceCreateInput!
}

input ChoiceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [ChoiceWhereInput!]
  OR: [ChoiceWhereInput!]
  NOT: [ChoiceWhereInput!]
}

input ChoiceWhereUniqueInput {
  id: ID
}

type CoverNode {
  id: ID!
  variant: Int!
  text: String!
}

type CoverNodeConnection {
  pageInfo: PageInfo!
  edges: [CoverNodeEdge]!
  aggregate: AggregateCoverNode!
}

input CoverNodeCreateInput {
  variant: Int
  text: String
}

input CoverNodeCreateManyInput {
  create: [CoverNodeCreateInput!]
  connect: [CoverNodeWhereUniqueInput!]
}

type CoverNodeEdge {
  node: CoverNode!
  cursor: String!
}

enum CoverNodeOrderByInput {
  id_ASC
  id_DESC
  variant_ASC
  variant_DESC
  text_ASC
  text_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CoverNodePreviousValues {
  id: ID!
  variant: Int!
  text: String!
}

input CoverNodeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  variant: Int
  variant_not: Int
  variant_in: [Int!]
  variant_not_in: [Int!]
  variant_lt: Int
  variant_lte: Int
  variant_gt: Int
  variant_gte: Int
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [CoverNodeScalarWhereInput!]
  OR: [CoverNodeScalarWhereInput!]
  NOT: [CoverNodeScalarWhereInput!]
}

type CoverNodeSubscriptionPayload {
  mutation: MutationType!
  node: CoverNode
  updatedFields: [String!]
  previousValues: CoverNodePreviousValues
}

input CoverNodeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CoverNodeWhereInput
  AND: [CoverNodeSubscriptionWhereInput!]
  OR: [CoverNodeSubscriptionWhereInput!]
  NOT: [CoverNodeSubscriptionWhereInput!]
}

input CoverNodeUpdateDataInput {
  variant: Int
  text: String
}

input CoverNodeUpdateInput {
  variant: Int
  text: String
}

input CoverNodeUpdateManyDataInput {
  variant: Int
  text: String
}

input CoverNodeUpdateManyInput {
  create: [CoverNodeCreateInput!]
  update: [CoverNodeUpdateWithWhereUniqueNestedInput!]
  upsert: [CoverNodeUpsertWithWhereUniqueNestedInput!]
  delete: [CoverNodeWhereUniqueInput!]
  connect: [CoverNodeWhereUniqueInput!]
  set: [CoverNodeWhereUniqueInput!]
  disconnect: [CoverNodeWhereUniqueInput!]
  deleteMany: [CoverNodeScalarWhereInput!]
  updateMany: [CoverNodeUpdateManyWithWhereNestedInput!]
}

input CoverNodeUpdateManyMutationInput {
  variant: Int
  text: String
}

input CoverNodeUpdateManyWithWhereNestedInput {
  where: CoverNodeScalarWhereInput!
  data: CoverNodeUpdateManyDataInput!
}

input CoverNodeUpdateWithWhereUniqueNestedInput {
  where: CoverNodeWhereUniqueInput!
  data: CoverNodeUpdateDataInput!
}

input CoverNodeUpsertWithWhereUniqueNestedInput {
  where: CoverNodeWhereUniqueInput!
  update: CoverNodeUpdateDataInput!
  create: CoverNodeCreateInput!
}

input CoverNodeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  variant: Int
  variant_not: Int
  variant_in: [Int!]
  variant_not_in: [Int!]
  variant_lt: Int
  variant_lte: Int
  variant_gt: Int
  variant_gte: Int
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [CoverNodeWhereInput!]
  OR: [CoverNodeWhereInput!]
  NOT: [CoverNodeWhereInput!]
}

input CoverNodeWhereUniqueInput {
  id: ID
}

scalar DateTime

type Exam {
  id: ID!
  published: Boolean!
  title: String!
  description: String
  code: String
  pass: Int
  time: Int
  image: String
  downloads: Int
  cover(where: CoverNodeWhereInput, orderBy: CoverNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CoverNode!]
  test(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Question!]
  user: User
  createdAt: DateTime!
}

type ExamConnection {
  pageInfo: PageInfo!
  edges: [ExamEdge]!
  aggregate: AggregateExam!
}

input ExamCreateInput {
  published: Boolean
  title: String!
  description: String
  code: String
  pass: Int
  time: Int
  image: String
  downloads: Int
  cover: CoverNodeCreateManyInput
  test: QuestionCreateManyInput
  user: UserCreateOneWithoutExamsInput
}

input ExamCreateManyWithoutUserInput {
  create: [ExamCreateWithoutUserInput!]
  connect: [ExamWhereUniqueInput!]
}

input ExamCreateWithoutUserInput {
  published: Boolean
  title: String!
  description: String
  code: String
  pass: Int
  time: Int
  image: String
  downloads: Int
  cover: CoverNodeCreateManyInput
  test: QuestionCreateManyInput
}

type ExamEdge {
  node: Exam!
  cursor: String!
}

enum ExamOrderByInput {
  id_ASC
  id_DESC
  published_ASC
  published_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  code_ASC
  code_DESC
  pass_ASC
  pass_DESC
  time_ASC
  time_DESC
  image_ASC
  image_DESC
  downloads_ASC
  downloads_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExamPreviousValues {
  id: ID!
  published: Boolean!
  title: String!
  description: String
  code: String
  pass: Int
  time: Int
  image: String
  downloads: Int
  createdAt: DateTime!
}

input ExamScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  published: Boolean
  published_not: Boolean
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  pass: Int
  pass_not: Int
  pass_in: [Int!]
  pass_not_in: [Int!]
  pass_lt: Int
  pass_lte: Int
  pass_gt: Int
  pass_gte: Int
  time: Int
  time_not: Int
  time_in: [Int!]
  time_not_in: [Int!]
  time_lt: Int
  time_lte: Int
  time_gt: Int
  time_gte: Int
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  downloads: Int
  downloads_not: Int
  downloads_in: [Int!]
  downloads_not_in: [Int!]
  downloads_lt: Int
  downloads_lte: Int
  downloads_gt: Int
  downloads_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ExamScalarWhereInput!]
  OR: [ExamScalarWhereInput!]
  NOT: [ExamScalarWhereInput!]
}

type ExamSubscriptionPayload {
  mutation: MutationType!
  node: Exam
  updatedFields: [String!]
  previousValues: ExamPreviousValues
}

input ExamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExamWhereInput
  AND: [ExamSubscriptionWhereInput!]
  OR: [ExamSubscriptionWhereInput!]
  NOT: [ExamSubscriptionWhereInput!]
}

input ExamUpdateInput {
  published: Boolean
  title: String
  description: String
  code: String
  pass: Int
  time: Int
  image: String
  downloads: Int
  cover: CoverNodeUpdateManyInput
  test: QuestionUpdateManyInput
  user: UserUpdateOneWithoutExamsInput
}

input ExamUpdateManyDataInput {
  published: Boolean
  title: String
  description: String
  code: String
  pass: Int
  time: Int
  image: String
  downloads: Int
}

input ExamUpdateManyMutationInput {
  published: Boolean
  title: String
  description: String
  code: String
  pass: Int
  time: Int
  image: String
  downloads: Int
}

input ExamUpdateManyWithoutUserInput {
  create: [ExamCreateWithoutUserInput!]
  delete: [ExamWhereUniqueInput!]
  connect: [ExamWhereUniqueInput!]
  set: [ExamWhereUniqueInput!]
  disconnect: [ExamWhereUniqueInput!]
  update: [ExamUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [ExamUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [ExamScalarWhereInput!]
  updateMany: [ExamUpdateManyWithWhereNestedInput!]
}

input ExamUpdateManyWithWhereNestedInput {
  where: ExamScalarWhereInput!
  data: ExamUpdateManyDataInput!
}

input ExamUpdateWithoutUserDataInput {
  published: Boolean
  title: String
  description: String
  code: String
  pass: Int
  time: Int
  image: String
  downloads: Int
  cover: CoverNodeUpdateManyInput
  test: QuestionUpdateManyInput
}

input ExamUpdateWithWhereUniqueWithoutUserInput {
  where: ExamWhereUniqueInput!
  data: ExamUpdateWithoutUserDataInput!
}

input ExamUpsertWithWhereUniqueWithoutUserInput {
  where: ExamWhereUniqueInput!
  update: ExamUpdateWithoutUserDataInput!
  create: ExamCreateWithoutUserInput!
}

input ExamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  published: Boolean
  published_not: Boolean
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  pass: Int
  pass_not: Int
  pass_in: [Int!]
  pass_not_in: [Int!]
  pass_lt: Int
  pass_lte: Int
  pass_gt: Int
  pass_gte: Int
  time: Int
  time_not: Int
  time_in: [Int!]
  time_not_in: [Int!]
  time_lt: Int
  time_lte: Int
  time_gt: Int
  time_gte: Int
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  downloads: Int
  downloads_not: Int
  downloads_in: [Int!]
  downloads_not_in: [Int!]
  downloads_lt: Int
  downloads_lte: Int
  downloads_gt: Int
  downloads_gte: Int
  cover_every: CoverNodeWhereInput
  cover_some: CoverNodeWhereInput
  cover_none: CoverNodeWhereInput
  test_every: QuestionWhereInput
  test_some: QuestionWhereInput
  test_none: QuestionWhereInput
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ExamWhereInput!]
  OR: [ExamWhereInput!]
  NOT: [ExamWhereInput!]
}

input ExamWhereUniqueInput {
  id: ID
}

type ExplanationNode {
  id: ID!
  variant: Int!
  text: String!
  href: String
}

type ExplanationNodeConnection {
  pageInfo: PageInfo!
  edges: [ExplanationNodeEdge]!
  aggregate: AggregateExplanationNode!
}

input ExplanationNodeCreateInput {
  variant: Int
  text: String
  href: String
}

input ExplanationNodeCreateManyInput {
  create: [ExplanationNodeCreateInput!]
  connect: [ExplanationNodeWhereUniqueInput!]
}

type ExplanationNodeEdge {
  node: ExplanationNode!
  cursor: String!
}

enum ExplanationNodeOrderByInput {
  id_ASC
  id_DESC
  variant_ASC
  variant_DESC
  text_ASC
  text_DESC
  href_ASC
  href_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExplanationNodePreviousValues {
  id: ID!
  variant: Int!
  text: String!
  href: String
}

input ExplanationNodeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  variant: Int
  variant_not: Int
  variant_in: [Int!]
  variant_not_in: [Int!]
  variant_lt: Int
  variant_lte: Int
  variant_gt: Int
  variant_gte: Int
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  href: String
  href_not: String
  href_in: [String!]
  href_not_in: [String!]
  href_lt: String
  href_lte: String
  href_gt: String
  href_gte: String
  href_contains: String
  href_not_contains: String
  href_starts_with: String
  href_not_starts_with: String
  href_ends_with: String
  href_not_ends_with: String
  AND: [ExplanationNodeScalarWhereInput!]
  OR: [ExplanationNodeScalarWhereInput!]
  NOT: [ExplanationNodeScalarWhereInput!]
}

type ExplanationNodeSubscriptionPayload {
  mutation: MutationType!
  node: ExplanationNode
  updatedFields: [String!]
  previousValues: ExplanationNodePreviousValues
}

input ExplanationNodeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExplanationNodeWhereInput
  AND: [ExplanationNodeSubscriptionWhereInput!]
  OR: [ExplanationNodeSubscriptionWhereInput!]
  NOT: [ExplanationNodeSubscriptionWhereInput!]
}

input ExplanationNodeUpdateDataInput {
  variant: Int
  text: String
  href: String
}

input ExplanationNodeUpdateInput {
  variant: Int
  text: String
  href: String
}

input ExplanationNodeUpdateManyDataInput {
  variant: Int
  text: String
  href: String
}

input ExplanationNodeUpdateManyInput {
  create: [ExplanationNodeCreateInput!]
  update: [ExplanationNodeUpdateWithWhereUniqueNestedInput!]
  upsert: [ExplanationNodeUpsertWithWhereUniqueNestedInput!]
  delete: [ExplanationNodeWhereUniqueInput!]
  connect: [ExplanationNodeWhereUniqueInput!]
  set: [ExplanationNodeWhereUniqueInput!]
  disconnect: [ExplanationNodeWhereUniqueInput!]
  deleteMany: [ExplanationNodeScalarWhereInput!]
  updateMany: [ExplanationNodeUpdateManyWithWhereNestedInput!]
}

input ExplanationNodeUpdateManyMutationInput {
  variant: Int
  text: String
  href: String
}

input ExplanationNodeUpdateManyWithWhereNestedInput {
  where: ExplanationNodeScalarWhereInput!
  data: ExplanationNodeUpdateManyDataInput!
}

input ExplanationNodeUpdateWithWhereUniqueNestedInput {
  where: ExplanationNodeWhereUniqueInput!
  data: ExplanationNodeUpdateDataInput!
}

input ExplanationNodeUpsertWithWhereUniqueNestedInput {
  where: ExplanationNodeWhereUniqueInput!
  update: ExplanationNodeUpdateDataInput!
  create: ExplanationNodeCreateInput!
}

input ExplanationNodeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  variant: Int
  variant_not: Int
  variant_in: [Int!]
  variant_not_in: [Int!]
  variant_lt: Int
  variant_lte: Int
  variant_gt: Int
  variant_gte: Int
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  href: String
  href_not: String
  href_in: [String!]
  href_not_in: [String!]
  href_lt: String
  href_lte: String
  href_gt: String
  href_gte: String
  href_contains: String
  href_not_contains: String
  href_starts_with: String
  href_not_starts_with: String
  href_ends_with: String
  href_not_ends_with: String
  AND: [ExplanationNodeWhereInput!]
  OR: [ExplanationNodeWhereInput!]
  NOT: [ExplanationNodeWhereInput!]
}

input ExplanationNodeWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createChoice(data: ChoiceCreateInput!): Choice!
  updateChoice(data: ChoiceUpdateInput!, where: ChoiceWhereUniqueInput!): Choice
  updateManyChoices(data: ChoiceUpdateManyMutationInput!, where: ChoiceWhereInput): BatchPayload!
  upsertChoice(where: ChoiceWhereUniqueInput!, create: ChoiceCreateInput!, update: ChoiceUpdateInput!): Choice!
  deleteChoice(where: ChoiceWhereUniqueInput!): Choice
  deleteManyChoices(where: ChoiceWhereInput): BatchPayload!
  createCoverNode(data: CoverNodeCreateInput!): CoverNode!
  updateCoverNode(data: CoverNodeUpdateInput!, where: CoverNodeWhereUniqueInput!): CoverNode
  updateManyCoverNodes(data: CoverNodeUpdateManyMutationInput!, where: CoverNodeWhereInput): BatchPayload!
  upsertCoverNode(where: CoverNodeWhereUniqueInput!, create: CoverNodeCreateInput!, update: CoverNodeUpdateInput!): CoverNode!
  deleteCoverNode(where: CoverNodeWhereUniqueInput!): CoverNode
  deleteManyCoverNodes(where: CoverNodeWhereInput): BatchPayload!
  createExam(data: ExamCreateInput!): Exam!
  updateExam(data: ExamUpdateInput!, where: ExamWhereUniqueInput!): Exam
  updateManyExams(data: ExamUpdateManyMutationInput!, where: ExamWhereInput): BatchPayload!
  upsertExam(where: ExamWhereUniqueInput!, create: ExamCreateInput!, update: ExamUpdateInput!): Exam!
  deleteExam(where: ExamWhereUniqueInput!): Exam
  deleteManyExams(where: ExamWhereInput): BatchPayload!
  createExplanationNode(data: ExplanationNodeCreateInput!): ExplanationNode!
  updateExplanationNode(data: ExplanationNodeUpdateInput!, where: ExplanationNodeWhereUniqueInput!): ExplanationNode
  updateManyExplanationNodes(data: ExplanationNodeUpdateManyMutationInput!, where: ExplanationNodeWhereInput): BatchPayload!
  upsertExplanationNode(where: ExplanationNodeWhereUniqueInput!, create: ExplanationNodeCreateInput!, update: ExplanationNodeUpdateInput!): ExplanationNode!
  deleteExplanationNode(where: ExplanationNodeWhereUniqueInput!): ExplanationNode
  deleteManyExplanationNodes(where: ExplanationNodeWhereInput): BatchPayload!
  createQuestion(data: QuestionCreateInput!): Question!
  updateQuestion(data: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question
  updateManyQuestions(data: QuestionUpdateManyMutationInput!, where: QuestionWhereInput): BatchPayload!
  upsertQuestion(where: QuestionWhereUniqueInput!, create: QuestionCreateInput!, update: QuestionUpdateInput!): Question!
  deleteQuestion(where: QuestionWhereUniqueInput!): Question
  deleteManyQuestions(where: QuestionWhereInput): BatchPayload!
  createQuestionNode(data: QuestionNodeCreateInput!): QuestionNode!
  updateQuestionNode(data: QuestionNodeUpdateInput!, where: QuestionNodeWhereUniqueInput!): QuestionNode
  updateManyQuestionNodes(data: QuestionNodeUpdateManyMutationInput!, where: QuestionNodeWhereInput): BatchPayload!
  upsertQuestionNode(where: QuestionNodeWhereUniqueInput!, create: QuestionNodeCreateInput!, update: QuestionNodeUpdateInput!): QuestionNode!
  deleteQuestionNode(where: QuestionNodeWhereUniqueInput!): QuestionNode
  deleteManyQuestionNodes(where: QuestionNodeWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  choice(where: ChoiceWhereUniqueInput!): Choice
  choices(where: ChoiceWhereInput, orderBy: ChoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Choice]!
  choicesConnection(where: ChoiceWhereInput, orderBy: ChoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChoiceConnection!
  coverNode(where: CoverNodeWhereUniqueInput!): CoverNode
  coverNodes(where: CoverNodeWhereInput, orderBy: CoverNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CoverNode]!
  coverNodesConnection(where: CoverNodeWhereInput, orderBy: CoverNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CoverNodeConnection!
  exam(where: ExamWhereUniqueInput!): Exam
  exams(where: ExamWhereInput, orderBy: ExamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Exam]!
  examsConnection(where: ExamWhereInput, orderBy: ExamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExamConnection!
  explanationNode(where: ExplanationNodeWhereUniqueInput!): ExplanationNode
  explanationNodes(where: ExplanationNodeWhereInput, orderBy: ExplanationNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExplanationNode]!
  explanationNodesConnection(where: ExplanationNodeWhereInput, orderBy: ExplanationNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExplanationNodeConnection!
  question(where: QuestionWhereUniqueInput!): Question
  questions(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Question]!
  questionsConnection(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuestionConnection!
  questionNode(where: QuestionNodeWhereUniqueInput!): QuestionNode
  questionNodes(where: QuestionNodeWhereInput, orderBy: QuestionNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [QuestionNode]!
  questionNodesConnection(where: QuestionNodeWhereInput, orderBy: QuestionNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuestionNodeConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Question {
  id: ID!
  variant: Int!
  question(where: QuestionNodeWhereInput, orderBy: QuestionNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [QuestionNode!]
  choices(where: ChoiceWhereInput, orderBy: ChoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Choice!]
  answer: [Boolean!]!
  explanation(where: ExplanationNodeWhereInput, orderBy: ExplanationNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExplanationNode!]
}

type QuestionConnection {
  pageInfo: PageInfo!
  edges: [QuestionEdge]!
  aggregate: AggregateQuestion!
}

input QuestionCreateanswerInput {
  set: [Boolean!]
}

input QuestionCreateInput {
  variant: Int
  question: QuestionNodeCreateManyInput
  choices: ChoiceCreateManyInput
  answer: QuestionCreateanswerInput
  explanation: ExplanationNodeCreateManyInput
}

input QuestionCreateManyInput {
  create: [QuestionCreateInput!]
  connect: [QuestionWhereUniqueInput!]
}

type QuestionEdge {
  node: Question!
  cursor: String!
}

type QuestionNode {
  id: ID!
  variant: Int!
  text: String!
}

type QuestionNodeConnection {
  pageInfo: PageInfo!
  edges: [QuestionNodeEdge]!
  aggregate: AggregateQuestionNode!
}

input QuestionNodeCreateInput {
  variant: Int
  text: String
}

input QuestionNodeCreateManyInput {
  create: [QuestionNodeCreateInput!]
  connect: [QuestionNodeWhereUniqueInput!]
}

type QuestionNodeEdge {
  node: QuestionNode!
  cursor: String!
}

enum QuestionNodeOrderByInput {
  id_ASC
  id_DESC
  variant_ASC
  variant_DESC
  text_ASC
  text_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type QuestionNodePreviousValues {
  id: ID!
  variant: Int!
  text: String!
}

input QuestionNodeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  variant: Int
  variant_not: Int
  variant_in: [Int!]
  variant_not_in: [Int!]
  variant_lt: Int
  variant_lte: Int
  variant_gt: Int
  variant_gte: Int
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [QuestionNodeScalarWhereInput!]
  OR: [QuestionNodeScalarWhereInput!]
  NOT: [QuestionNodeScalarWhereInput!]
}

type QuestionNodeSubscriptionPayload {
  mutation: MutationType!
  node: QuestionNode
  updatedFields: [String!]
  previousValues: QuestionNodePreviousValues
}

input QuestionNodeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuestionNodeWhereInput
  AND: [QuestionNodeSubscriptionWhereInput!]
  OR: [QuestionNodeSubscriptionWhereInput!]
  NOT: [QuestionNodeSubscriptionWhereInput!]
}

input QuestionNodeUpdateDataInput {
  variant: Int
  text: String
}

input QuestionNodeUpdateInput {
  variant: Int
  text: String
}

input QuestionNodeUpdateManyDataInput {
  variant: Int
  text: String
}

input QuestionNodeUpdateManyInput {
  create: [QuestionNodeCreateInput!]
  update: [QuestionNodeUpdateWithWhereUniqueNestedInput!]
  upsert: [QuestionNodeUpsertWithWhereUniqueNestedInput!]
  delete: [QuestionNodeWhereUniqueInput!]
  connect: [QuestionNodeWhereUniqueInput!]
  set: [QuestionNodeWhereUniqueInput!]
  disconnect: [QuestionNodeWhereUniqueInput!]
  deleteMany: [QuestionNodeScalarWhereInput!]
  updateMany: [QuestionNodeUpdateManyWithWhereNestedInput!]
}

input QuestionNodeUpdateManyMutationInput {
  variant: Int
  text: String
}

input QuestionNodeUpdateManyWithWhereNestedInput {
  where: QuestionNodeScalarWhereInput!
  data: QuestionNodeUpdateManyDataInput!
}

input QuestionNodeUpdateWithWhereUniqueNestedInput {
  where: QuestionNodeWhereUniqueInput!
  data: QuestionNodeUpdateDataInput!
}

input QuestionNodeUpsertWithWhereUniqueNestedInput {
  where: QuestionNodeWhereUniqueInput!
  update: QuestionNodeUpdateDataInput!
  create: QuestionNodeCreateInput!
}

input QuestionNodeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  variant: Int
  variant_not: Int
  variant_in: [Int!]
  variant_not_in: [Int!]
  variant_lt: Int
  variant_lte: Int
  variant_gt: Int
  variant_gte: Int
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [QuestionNodeWhereInput!]
  OR: [QuestionNodeWhereInput!]
  NOT: [QuestionNodeWhereInput!]
}

input QuestionNodeWhereUniqueInput {
  id: ID
}

enum QuestionOrderByInput {
  id_ASC
  id_DESC
  variant_ASC
  variant_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type QuestionPreviousValues {
  id: ID!
  variant: Int!
  answer: [Boolean!]!
}

input QuestionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  variant: Int
  variant_not: Int
  variant_in: [Int!]
  variant_not_in: [Int!]
  variant_lt: Int
  variant_lte: Int
  variant_gt: Int
  variant_gte: Int
  AND: [QuestionScalarWhereInput!]
  OR: [QuestionScalarWhereInput!]
  NOT: [QuestionScalarWhereInput!]
}

type QuestionSubscriptionPayload {
  mutation: MutationType!
  node: Question
  updatedFields: [String!]
  previousValues: QuestionPreviousValues
}

input QuestionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuestionWhereInput
  AND: [QuestionSubscriptionWhereInput!]
  OR: [QuestionSubscriptionWhereInput!]
  NOT: [QuestionSubscriptionWhereInput!]
}

input QuestionUpdateanswerInput {
  set: [Boolean!]
}

input QuestionUpdateDataInput {
  variant: Int
  question: QuestionNodeUpdateManyInput
  choices: ChoiceUpdateManyInput
  answer: QuestionUpdateanswerInput
  explanation: ExplanationNodeUpdateManyInput
}

input QuestionUpdateInput {
  variant: Int
  question: QuestionNodeUpdateManyInput
  choices: ChoiceUpdateManyInput
  answer: QuestionUpdateanswerInput
  explanation: ExplanationNodeUpdateManyInput
}

input QuestionUpdateManyDataInput {
  variant: Int
  answer: QuestionUpdateanswerInput
}

input QuestionUpdateManyInput {
  create: [QuestionCreateInput!]
  update: [QuestionUpdateWithWhereUniqueNestedInput!]
  upsert: [QuestionUpsertWithWhereUniqueNestedInput!]
  delete: [QuestionWhereUniqueInput!]
  connect: [QuestionWhereUniqueInput!]
  set: [QuestionWhereUniqueInput!]
  disconnect: [QuestionWhereUniqueInput!]
  deleteMany: [QuestionScalarWhereInput!]
  updateMany: [QuestionUpdateManyWithWhereNestedInput!]
}

input QuestionUpdateManyMutationInput {
  variant: Int
  answer: QuestionUpdateanswerInput
}

input QuestionUpdateManyWithWhereNestedInput {
  where: QuestionScalarWhereInput!
  data: QuestionUpdateManyDataInput!
}

input QuestionUpdateWithWhereUniqueNestedInput {
  where: QuestionWhereUniqueInput!
  data: QuestionUpdateDataInput!
}

input QuestionUpsertWithWhereUniqueNestedInput {
  where: QuestionWhereUniqueInput!
  update: QuestionUpdateDataInput!
  create: QuestionCreateInput!
}

input QuestionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  variant: Int
  variant_not: Int
  variant_in: [Int!]
  variant_not_in: [Int!]
  variant_lt: Int
  variant_lte: Int
  variant_gt: Int
  variant_gte: Int
  question_every: QuestionNodeWhereInput
  question_some: QuestionNodeWhereInput
  question_none: QuestionNodeWhereInput
  choices_every: ChoiceWhereInput
  choices_some: ChoiceWhereInput
  choices_none: ChoiceWhereInput
  explanation_every: ExplanationNodeWhereInput
  explanation_some: ExplanationNodeWhereInput
  explanation_none: ExplanationNodeWhereInput
  AND: [QuestionWhereInput!]
  OR: [QuestionWhereInput!]
  NOT: [QuestionWhereInput!]
}

input QuestionWhereUniqueInput {
  id: ID
}

enum Role {
  USER
  ADMIN
}

type Subscription {
  choice(where: ChoiceSubscriptionWhereInput): ChoiceSubscriptionPayload
  coverNode(where: CoverNodeSubscriptionWhereInput): CoverNodeSubscriptionPayload
  exam(where: ExamSubscriptionWhereInput): ExamSubscriptionPayload
  explanationNode(where: ExplanationNodeSubscriptionWhereInput): ExplanationNodeSubscriptionPayload
  question(where: QuestionSubscriptionWhereInput): QuestionSubscriptionPayload
  questionNode(where: QuestionNodeSubscriptionWhereInput): QuestionNodeSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  googleID: String
  name: String!
  password: String
  email: String
  image: String
  homepage: String
  role: Role!
  exams(where: ExamWhereInput, orderBy: ExamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Exam!]
  createdAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  googleID: String
  name: String!
  password: String
  email: String
  image: String
  homepage: String
  role: Role
  exams: ExamCreateManyWithoutUserInput
}

input UserCreateOneWithoutExamsInput {
  create: UserCreateWithoutExamsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutExamsInput {
  googleID: String
  name: String!
  password: String
  email: String
  image: String
  homepage: String
  role: Role
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  googleID_ASC
  googleID_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
  email_ASC
  email_DESC
  image_ASC
  image_DESC
  homepage_ASC
  homepage_DESC
  role_ASC
  role_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  googleID: String
  name: String!
  password: String
  email: String
  image: String
  homepage: String
  role: Role!
  createdAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  googleID: String
  name: String
  password: String
  email: String
  image: String
  homepage: String
  role: Role
  exams: ExamUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  googleID: String
  name: String
  password: String
  email: String
  image: String
  homepage: String
  role: Role
}

input UserUpdateOneWithoutExamsInput {
  create: UserCreateWithoutExamsInput
  update: UserUpdateWithoutExamsDataInput
  upsert: UserUpsertWithoutExamsInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutExamsDataInput {
  googleID: String
  name: String
  password: String
  email: String
  image: String
  homepage: String
  role: Role
}

input UserUpsertWithoutExamsInput {
  update: UserUpdateWithoutExamsDataInput!
  create: UserCreateWithoutExamsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  googleID: String
  googleID_not: String
  googleID_in: [String!]
  googleID_not_in: [String!]
  googleID_lt: String
  googleID_lte: String
  googleID_gt: String
  googleID_gte: String
  googleID_contains: String
  googleID_not_contains: String
  googleID_starts_with: String
  googleID_not_starts_with: String
  googleID_ends_with: String
  googleID_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  homepage: String
  homepage_not: String
  homepage_in: [String!]
  homepage_not_in: [String!]
  homepage_lt: String
  homepage_lte: String
  homepage_gt: String
  homepage_gte: String
  homepage_contains: String
  homepage_not_contains: String
  homepage_starts_with: String
  homepage_not_starts_with: String
  homepage_ends_with: String
  homepage_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  exams_every: ExamWhereInput
  exams_some: ExamWhereInput
  exams_none: ExamWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  googleID: String
  email: String
}
`
      }
    